## 文件结构
1. ./announcer: 没什么用
2. ./validator: 没什么用
3. ./util: 一个关于使用channel作为输入输出缓存的工具函数，具体说，实现了一个带有Buffer的输入输出通道，同时带有一个周期启动某函数的功能
4. ./config: 一个读取配置的文件，然后在这里可以设置Log等级
5. ./crypto: 保存了在区块链中常用的加密工具
6. ./tracing: 一个汇集各类event以及追踪记录其方法的工具，估计只是为了追踪某些事件设计的
7. ./tsl-data: 身份信息
8. ./profiling: 性能分析工具，追踪cpu并记录为文件
9. ./discovery： 客户和节点之间互相发现的方法
    * client 有关于注册和发现服务器的方法
    * server 有启动服务器和发现其他节点的方法
    * rpcs 定义了通信协议
    * master 是接受命令并指示server调整配置的文件
10. ./cmd 盲猜是用于启动各个模块的代码，如启动发现服务，启动client，启动server等等
## 实际需要关注的
1. ./log:
    * 区块链的结构是： 区块是一个个Entry，而Log则为链本身
    * entry： 定义了区块的结构，其中Suspect估计是用于黑名单
    * log： 描述了区块链日志的基本功能，如提交区块，调出区块，以及用于其他节点跟进CatchUp的发布和订阅区块
2. ./request: 
    * 客户的请求先进入Bucket中，然后由BucketGroup剪切成Batch
    *  bucket 实现了一个带有锁的双向链表结构，用于添加或移除事务
    *  bucketGroup 实现了了从Bucket到Batch的一步，具体说就是根据特定的定时或者数量按时取出Req组织成Batch
    *  request 描述了Req进入共识前的方法，其中有Req的Buffer和Bucket的分配，Req跟随Watermark的移动，Req的哈希计算等等
    *  buffer 似乎是Client自己的Buffer 用于记录和缓存自己的Req 其中包含了缓存未到使用的Req 推进WaterMark并取出Backlog
    *  batch 是Client的信息到来的第一部处理，用于制作成Batch或者将Batch还原成CLientReqMsg，还包括一些检测回收没有被提议的Req，验证哈希等附加功能
    *  requesthandler 用于存放Req，多个线程处理
    *  responder 监听logChan并响应信息
3. ./statetransfer: 一个处理missing entry的包，包括描述节点如何发起catch up和如何响应该request，之所以叫做这个名词，估计本义是说该文件用于同步状态进度
4. ./manger: 
    * manger是管理各个模块交互的部分，如如何分配Seg，如何让节点并行执行共识，如何实现跟进同步等等，不过不清楚这个是每个节点均有的模块还是中心的模块
    * segment： 论文中所说的Seg
    * contiguous segment: 就是论文中的Seg结构
    * skipping segment： 应该并非是作者文中示范的Seg结构，他的seg中的SN可以跳跃
    * leader policies: 用于选领导节点，提供了以下的方法： Simple(所有节点均为leader) Single(按轮转法根据epoch和len(node)选出) Backoff（根据配置直接禁用某些节点） Blacklist(根据节点提供的黑名单禁用某些节点)
    * manger: 一个接口
    * mir manger: 真正的manger，他主要负责两件事情： 1. 处理Entry,从本地节点的Log中不断分析entry，根据是否Aborted更新黑名单，根据Sn判断是否新的Epoch并初始化该Epoch的一些变量，签发新的Seg（根据规则划分出Seg，找到自己的Seg并确认桶的分配） 2. 监听新的Checkpoint并在落后时跟进
    * dummy manger： 还不用看

4. ./protobufs: 保存了该项目所使用的数据结构：
5. ./membership: 一个描述节点验证信息的文件，用于初始化client和node的密钥身份
6. ./orderer： 具体的共识协议